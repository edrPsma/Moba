using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Collections.Generic;

namespace SourceGenerator
{
    [Generator]
    public class ProtocolMapGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context) { }

        public void Execute(GeneratorExecutionContext context)
        {
            List<string> classNames = new List<string>();

            // 遍历所有语法树
            foreach (var syntaxTree in context.Compilation.SyntaxTrees)
            {
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var root = syntaxTree.GetRoot();


                // 查找所有类声明
                var classNodes = root.DescendantNodes().OfType<ClassDeclarationSyntax>();
                foreach (var classNode in classNodes)
                {
                    var symbol = semanticModel.GetDeclaredSymbol(classNode) as INamedTypeSymbol;
                    if (symbol == null) continue;

                    // 判断是否实现了 IMessage 接口
                    if (symbol.AllInterfaces.Any(i => i.Name == "IMessage") && !symbol.IsAbstract)
                    {
                        var ns = symbol.ContainingNamespace.ToDisplayString();
                        var className = symbol.Name;
                        var fullClassName = symbol.ToDisplayString();

                        classNames.Add(fullClassName);

                    }
                }
            }

            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < classNames.Count; i++)
            {
                short uid = Crc16(classNames[i]);
                sb.Append("{");
                sb.Append($"{uid},()=>new {classNames[i]}()");
                sb.Append("},\r\n");
            }

            StringBuilder sb2 = new StringBuilder();

            for (int i = 0; i < classNames.Count; i++)
            {
                short uid = Crc16(classNames[i]);
                sb2.Append("{");
                sb2.Append($"typeof({classNames[i]}),{uid}");
                sb2.Append("},\r\n");
            }

            var source = $@"
            // <auto-generated />
            using System;
            using System.Collections.Generic;
            using Google.Protobuf;

            namespace Protocol
            {{
                public partial class MessageBuilder
                {{
                    static Dictionary<short, Func<IMessage>> _mapper = new Dictionary<short, Func<IMessage>>
                    {{
                        {sb}
                    }};

                    static Dictionary<Type, short> _map = new Dictionary<Type, short>
                    {{
                        {sb2}
                    }};

                    public static IMessage Build(short messageID)
                    {{
                        if (_mapper.ContainsKey(messageID))
                        {{
                            return _mapper[messageID]?.Invoke();
                        }}
                        else
                        {{
                            return null;
                        }}
                    }}

                    public static short QueryMessageID(Type type)
                    {{
                        if (_map.ContainsKey(type))
                        {{
                            return _map[type];
                        }}
                        else
                        {{
                            return 0;
                        }}
                    }}
                }}
            }}
            ";
            context.AddSource($"MessageBuilder.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        public static short Crc16(string input)
        {
            ushort crc = 0xFFFF;
            foreach (byte b in Encoding.UTF8.GetBytes(input))
            {
                crc ^= (ushort)(b << 8);
                for (int i = 0; i < 8; i++)
                    crc = (ushort)((crc & 0x8000) != 0 ? (crc << 1) ^ 0x1021 : crc << 1);
            }
            return (short)crc;
        }
    }
}